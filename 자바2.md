⭐️ 정리 범위 (이미 내가 설명했던 부분들은 빼고, 새 내용 중심)

✔ Shadowing(섀도잉)
✔ Local Class(로컬 클래스)
✔ Anonymous Class(익명 클래스)
✔ 사실상 final(effectively final)
✔ Nested Static Class vs Top-Level Class 차이
✔ 생성자 없는 익명 클래스에서의 “초기화 블록 {}”
✔ 익명 클래스에서 메서드를 추가하면 왜 밖에서 못 부르는지
✔ 로컬 클래스/익명 클래스의 지역 변수 캡처

이 부분들만 코드 예제로 완전 쉽게 갈게.

⭐️ 1. Shadowing(섀도잉)

안쪽 범위의 변수 이름이 바깥 변수와 같으면, 바깥 변수를 가려버림

✔ 예제
public class ShadowTest {
    int x = 0; // 외부 클래스 변수

    class Inner {
        int x = 1; // 내부 클래스 변수

        void print(int x) {  // 파라미터 x
            System.out.println("파라미터 x = " + x);
            System.out.println("Inner의 x = " + this.x);
            System.out.println("ShadowTest의 x = " + ShadowTest.this.x);
        }
    }

    public static void main(String[] args) {
        ShadowTest outer = new ShadowTest();
        ShadowTest.Inner inner = outer.new Inner();
        inner.print(23);
    }
}

✔ 출력
파라미터 x = 23
Inner의 x = 1
ShadowTest의 x = 0

✔ 핵심

x = 23 → 메서드 파라미터

this.x = 1 → Inner 클래스의 x

ShadowTest.this.x = 0 → 외부(Outer) x

이게 “섀도잉”.

⭐️ 2. 로컬 클래스(Local Class)

메서드 안에서만 사용하는 작은 클래스

✔ 예제
void printMessage() {

    class LocalPrinter {   // 메서드 안에서 선언되는 클래스
        void print() {
            System.out.println("나는 로컬 클래스");
        }
    }

    LocalPrinter lp = new LocalPrinter();
    lp.print();
}

✔ 특징

메서드 안에서만 사용 가능

메서드 밖에서는 절대 접근 불가

static 멤버 선언 불가 (상수만 가능)

외부(이 메서드를 포함하는 클래스) 멤버에 접근 가능

⭐️ 3. 익명 클래스(Anonymous Class)

이름 없는 클래스
클래스 선언 + 인스턴스 생성이 한 번에 이루어짐.

✔ 예제
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("익명 클래스 실행!");
    }
};

r.run();

✔ 핵심

new Runnable() 뒤에 { } 붙은 것이 익명 클래스

이름이 없기 때문에 “클래스 파일”은 컴파일 시 자동 만들지만, 코드에서는 이름 없음

딱 한 번만 사용할 때 쓰기 좋음

⭐️ 4. 익명 클래스는 “생성자”를 가질 수 없다

❌ 이렇게 못함:

new Runnable() {
    public Runnable() {} // 불가능
}


→ 익명 클래스에는 클래스 이름이 없기 때문에 생성자 자체를 만들 수 없음.

⭐️ 5. 그래서 익명 클래스는 “초기화 블록 {}”을 사용
✔ 익명 클래스 초기화 방식 예제
Person p = new Person() {
    private String job;

    {
        setName("서령");
        job = "개발자";
    }

    @Override
    public void introduce() {
        System.out.println(getName() + " / 직업: " + job);
    }
};

p.introduce();

⭐️ 6. 익명 클래스에서 새 메서드를 만들 수 있지만, 밖에서 못 부르는 이유
Person p = new Person() {
    void code() {
        System.out.println("코딩중!");
    }
};


왜 p.code()가 안될까?

이유:

변수 타입이 Person이기 때문.

변수 타입(Person)은 부모 타입이므로, 부모가 가진 메서드만 호출 가능.

익명 클래스 내부에서만 쓸 수 있는 “숨겨진 메서드”가 되는 것.

⭐️ 7. Effectively final (사실상 final)

지역 변수를 익명/로컬 클래스가 참조하려면 고정값이어야 함
즉, “초기화 이후 값이 변경되지 않으면 final처럼 취급”

✔ 정상 작동
void test() {
    int num = 10;  // 변경 없음 = 사실상 final

    Runnable r = new Runnable() {
        @Override
        public void run() {
            System.out.println(num); // OK
        }
    };
}

✔ 에러
void test() {
    int num = 10;

    Runnable r = new Runnable() {
        @Override
        public void run() {
            System.out.println(num);
        }
    };

    num = 20;  // 값 변경 → final 아님 → 에러
}


익명 클래스는 num을 “캡처”해야 하는데, 값이 변하면 불가능한 구조라서 그래.

⭐️ 8. Top-Level Class vs Static Nested Class 차이
✔ Top-Level Class
public class A { }
class B { }


파일 바깥에 있는 클래스

public 또는 (package-private)만 가능

✔ Static Nested Class
class A {
    static class B { }
}


파일은 A 하나

A 안에 B가 들어있지만, 행동은 top-level과 거의 동일

외부 A의 인스턴스에 접근 불가

그냥 “정리 및 숨기기용”

✔ 사용법
A.B obj = new A.B();

⭐️ 9. 내부 클래스는 왜 static 멤버를 못 가질까?
이유 (초간단):

내부 클래스는 "Outer 객체에 붙어서 사는 존재"
→ 인스턴스 기반
→ 클래스(static) 멤버를 가질 수 없음

예:
class Outer {
    class Inner {
        static int x = 10; // ❌ 오류
    }
}

⭐️ 10. 중첩 클래스 전체 요약 (코딩 기준)
Top-Level Class (파일의 바깥 클래스)
 └─ 중첩 클래스(Nested Class)
      ├─ inner class (비정적)
      │    - outer.new Inner()
      │    - Outer 멤버 모두 접근 가능
      │    - static 멤버 선언 불가능
      │
      ├─ static nested class
      │    - new Outer.Nested()
      │    - Outer의 인스턴스 멤버 직접 접근 불가
      │    - static 멤버 가능
      │
      ├─ local class (메서드 안)
      │    - 메서드 안 전용
      │    - static 멤버 거의 불가
      │
      └─ anonymous class (이름 없음)
           - new 인터페이스() { ... }
           - 생성자 없음 → 초기화 블록 사용
           - 새 메서드 만들어도 타입 때문에 밖에서 호출 불가
